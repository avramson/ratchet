package runbook_worker

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/dynoinc/ratchet/internal"
	"github.com/dynoinc/ratchet/internal/background"
	"github.com/dynoinc/ratchet/internal/llm"
	"github.com/dynoinc/ratchet/internal/slack_integration"
	"github.com/dynoinc/ratchet/internal/storage/schema"
	"github.com/dynoinc/ratchet/internal/storage/schema/dto"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/pgvector/pgvector-go"
	"github.com/riverqueue/river"
	"github.com/slack-go/slack"
)

type postRunbookWorker struct {
	river.WorkerDefaults[background.PostRunbookWorkerArgs]

	bot              *internal.Bot
	slackIntegration *slack_integration.Integration
	llmClient        *llm.Client
}

func NewPostRunbookWorker(
	bot *internal.Bot,
	slackIntegration *slack_integration.Integration,
	llmClient *llm.Client,
) *postRunbookWorker {
	return &postRunbookWorker{
		bot:              bot,
		slackIntegration: slackIntegration,
		llmClient:        llmClient,
	}
}
func (w *postRunbookWorker) Work(ctx context.Context, job *river.Job[background.PostRunbookWorkerArgs]) error {
	msg, err := w.bot.GetMessage(ctx, job.Args.ChannelID, job.Args.SlackTS)
	if err != nil {
		if errors.Is(err, internal.ErrMessageNotFound) {
			return nil
		}

		return fmt.Errorf("getting message: %w", err)
	}
	serviceName := msg.Attrs.IncidentAction.Service
	alertName := msg.Attrs.IncidentAction.Alert

	runbook, err := schema.New(w.bot.DB).GetRunbook(ctx, schema.GetRunbookParams{
		ServiceName: serviceName,
		AlertName:   alertName,
	})
	if err != nil && !errors.Is(err, pgx.ErrNoRows) {
		return fmt.Errorf("getting runbook: %w", err)
	}
	runbookMessage := runbook.Attrs.Runbook
	if runbookMessage == "" {
		runbookMessage, err = updateRunbook(ctx, serviceName, alertName, false, schema.New(w.bot.DB), w.llmClient)
		if err != nil {
			return fmt.Errorf("updating runbook: %w", err)
		}
	}

	updates, err := GetUpdates(ctx, w.bot.DB, w.llmClient, serviceName, alertName, time.Hour, w.slackIntegration.BotUserID)
	if err != nil {
		return fmt.Errorf("getting updates: %w", err)
	}

	blocks := w.formatRunbookMessage(serviceName, alertName, runbookMessage, updates)
	return w.slackIntegration.PostThreadReply(ctx, job.Args.ChannelID, job.Args.SlackTS, blocks...)
}

func (w *postRunbookWorker) formatRunbookMessage(
	serviceName, alertName, runbookMessage string,
	updates []schema.MessagesV2,
) []slack.Block {
	// Create blocks array and add header
	blocks := []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject(slack.PlainTextType, fmt.Sprintf("Runbook for %s - %s", serviceName, alertName), false, false),
		),
		slack.NewDividerBlock(),
	}

	// Add runbook content
	if len(runbookMessage) > 0 {
		blocks = append(blocks,
			slack.NewSectionBlock(
				slack.NewTextBlockObject(slack.MarkdownType, "*Runbook:*", false, false),
				nil, nil,
			),
			slack.NewSectionBlock(
				slack.NewTextBlockObject(slack.MarkdownType, runbookMessage, false, false),
				nil, nil,
			),
		)
	} else {
		blocks = append(blocks, slack.NewSectionBlock(
			slack.NewTextBlockObject(slack.MarkdownType, "_No runbook found for this alert_", false, false),
			nil, nil,
		))
	}

	// Add divider before updates section
	blocks = append(blocks, slack.NewDividerBlock())

	if len(updates) > 0 {
		blocks = append(blocks,
			slack.NewSectionBlock(
				slack.NewTextBlockObject(slack.MarkdownType, "*Recent Activity:*", false, false),
				nil, nil,
			),
		)

		for _, update := range updates {
			messageLink := fmt.Sprintf("https://slack.com/app_redirect?channel=%s&message_ts=%s",
				update.ChannelID, update.Ts)
			updateText := fmt.Sprintf("â€¢ <%s|%s> (%s)",
				messageLink, update.Attrs.Message.Text, update.Attrs.Message.User)

			blocks = append(blocks, slack.NewSectionBlock(
				slack.NewTextBlockObject(slack.MarkdownType, updateText, false, false),
				nil, nil,
			))
		}
	} else {
		blocks = append(blocks, slack.NewSectionBlock(
			slack.NewTextBlockObject(slack.MarkdownType, "_No recent activity found in the last hour_", false, false),
			nil, nil,
		))
	}

	// Add divider before footer
	blocks = append(blocks, slack.NewDividerBlock())

	// Add footer
	blocks = append(blocks, slack.NewSectionBlock(
		slack.NewTextBlockObject(slack.MarkdownType,
			fmt.Sprintf("_Generated by Ratchet at %s_", time.Now().Format(time.RFC1123)),
			false, false,
		),
		nil, nil,
	))

	return blocks
}

func GetUpdates(
	ctx context.Context,
	db *pgxpool.Pool,
	llmClient *llm.Client,
	serviceName, alertName string,
	interval time.Duration,
	botID string,
) ([]schema.MessagesV2, error) {
	queryText := fmt.Sprintf("%s %s", serviceName, alertName)
	queryEmbedding, err := llmClient.GenerateEmbedding(ctx, "search_query", queryText)
	if err != nil {
		return nil, fmt.Errorf("generating embedding: %w", err)
	}

	embedding := pgvector.NewVector(queryEmbedding)
	updates, err := schema.New(db).GetLatestServiceUpdates(ctx, schema.GetLatestServiceUpdatesParams{
		QueryText:      queryText,
		QueryEmbedding: &embedding,
		Interval:       pgtype.Interval{Microseconds: interval.Microseconds(), Valid: true},
		BotID:          botID,
	})
	if err != nil {
		return nil, fmt.Errorf("getting latest service updates: %w", err)
	}

	messages := make([]schema.MessagesV2, len(updates))
	for i, update := range updates {
		var attrs dto.MessageAttrs
		if err := json.Unmarshal(update.Attrs, &attrs); err != nil {
			return nil, fmt.Errorf("unmarshalling message attrs: %w", err)
		}

		messages[i] = schema.MessagesV2{
			ChannelID: update.ChannelID,
			Ts:        update.Ts,
			Attrs:     attrs,
		}
	}

	return messages, nil
}
