// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: documentation.sql

package schema

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const debugGetClosestDocs = `-- name: DebugGetClosestDocs :many
WITH ranked_chunks AS (
    SELECT
        e.url,
        e.path,
        e.blob_sha,
        e.chunk_index,
        e.chunk,
        e.embedding <=> $2 AS distance,
        ROW_NUMBER() OVER (PARTITION BY e.url, e.path, e.blob_sha ORDER BY e.embedding <=> $2 ASC) as rn
    FROM
        documentation_embeddings e
),
closest_doc_chunks AS (
    SELECT
        url,
        path,
        blob_sha,
        chunk_index,
        chunk,
        distance
    FROM
        ranked_chunks
    WHERE
        rn = 1
)
SELECT
    url, path, blob_sha, chunk_index, chunk, distance
FROM
    closest_doc_chunks
ORDER BY
    distance ASC
LIMIT $1
`

type DebugGetClosestDocsParams struct {
	LimitVal  int32
	Embedding *pgvector.Vector
}

type DebugGetClosestDocsRow struct {
	Url        string
	Path       string
	BlobSha    string
	ChunkIndex int32
	Chunk      string
	Distance   interface{}
}

func (q *Queries) DebugGetClosestDocs(ctx context.Context, arg DebugGetClosestDocsParams) ([]DebugGetClosestDocsRow, error) {
	rows, err := q.db.Query(ctx, debugGetClosestDocs, arg.LimitVal, arg.Embedding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DebugGetClosestDocsRow
	for rows.Next() {
		var i DebugGetClosestDocsRow
		if err := rows.Scan(
			&i.Url,
			&i.Path,
			&i.BlobSha,
			&i.ChunkIndex,
			&i.Chunk,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const debugGetDocumentForUpdate = `-- name: DebugGetDocumentForUpdate :many
WITH closest_chunks AS (
  SELECT e.url,
    e.path,
    e.blob_sha,
    e.chunk_index,
    e.chunk,
    e.embedding,
    e.embedding <=> $1 as distance
  FROM documentation_embeddings e
  ORDER BY e.embedding <=> $1
  LIMIT 25)
SELECT c.url,
      c.path,
      c.blob_sha,
      c.chunk_index,
      c.chunk,
      c.distance,
      COUNT(*) OVER (PARTITION BY c.url, c.path, c.blob_sha) as chunk_count,
      AVG(c.distance) OVER (PARTITION BY c.url, c.path, c.blob_sha) as avg_distance,
      MIN(c.distance) OVER (PARTITION BY c.url, c.path, c.blob_sha) as min_distance
FROM closest_chunks c
ORDER BY min_distance ASC, c.url, c.path, c.blob_sha, c.chunk_index
`

type DebugGetDocumentForUpdateRow struct {
	Url         string
	Path        string
	BlobSha     string
	ChunkIndex  int32
	Chunk       string
	Distance    interface{}
	ChunkCount  int64
	AvgDistance float64
	MinDistance interface{}
}

func (q *Queries) DebugGetDocumentForUpdate(ctx context.Context, embedding *pgvector.Vector) ([]DebugGetDocumentForUpdateRow, error) {
	rows, err := q.db.Query(ctx, debugGetDocumentForUpdate, embedding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DebugGetDocumentForUpdateRow
	for rows.Next() {
		var i DebugGetDocumentForUpdateRow
		if err := rows.Scan(
			&i.Url,
			&i.Path,
			&i.BlobSha,
			&i.ChunkIndex,
			&i.Chunk,
			&i.Distance,
			&i.ChunkCount,
			&i.AvgDistance,
			&i.MinDistance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteDoc = `-- name: DeleteDoc :exec
DELETE
FROM documentation_docs
WHERE url = $1
  AND path = $2
`

type DeleteDocParams struct {
	Url  string
	Path string
}

func (q *Queries) DeleteDoc(ctx context.Context, arg DeleteDocParams) error {
	_, err := q.db.Exec(ctx, deleteDoc, arg.Url, arg.Path)
	return err
}

const getClosestDocs = `-- name: GetClosestDocs :many
WITH ranked_chunks AS (
    SELECT
        e.url,
        e.path,
        e.blob_sha,
        e.embedding <=> $2 AS distance,
        ROW_NUMBER() OVER (PARTITION BY e.url, e.path, e.blob_sha ORDER BY e.embedding <=> $2 ASC) as rn
    FROM
        documentation_embeddings e
),
closest_doc_chunks AS (
    SELECT
        url,
        path,
        blob_sha,
        distance
    FROM
        ranked_chunks
    WHERE
        rn = 1
)
SELECT
    cdc.url,
    cdc.path,
    d.revision,
    d.content
FROM
    closest_doc_chunks cdc
JOIN
    documentation_docs d ON cdc.url = d.url AND cdc.path = d.path AND cdc.blob_sha = d.blob_sha
ORDER BY
    cdc.distance ASC
LIMIT $1
`

type GetClosestDocsParams struct {
	LimitVal  int32
	Embedding *pgvector.Vector
}

type GetClosestDocsRow struct {
	Url      string
	Path     string
	Revision string
	Content  string
}

func (q *Queries) GetClosestDocs(ctx context.Context, arg GetClosestDocsParams) ([]GetClosestDocsRow, error) {
	rows, err := q.db.Query(ctx, getClosestDocs, arg.LimitVal, arg.Embedding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClosestDocsRow
	for rows.Next() {
		var i GetClosestDocsRow
		if err := rows.Scan(
			&i.Url,
			&i.Path,
			&i.Revision,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocument = `-- name: GetDocument :one
SELECT url, path, revision, content, blob_sha
FROM documentation_docs
WHERE url = $1
  AND path = $2
  AND revision = $3
`

type GetDocumentParams struct {
	Url      string
	Path     string
	Revision string
}

func (q *Queries) GetDocument(ctx context.Context, arg GetDocumentParams) (DocumentationDoc, error) {
	row := q.db.QueryRow(ctx, getDocument, arg.Url, arg.Path, arg.Revision)
	var i DocumentationDoc
	err := row.Scan(
		&i.Url,
		&i.Path,
		&i.Revision,
		&i.Content,
		&i.BlobSha,
	)
	return i, err
}

const getDocumentForUpdate = `-- name: GetDocumentForUpdate :one
WITH closest_chunks AS (SELECT e.url,
                               e.path,
                               e.blob_sha,
                               e.chunk_index,
                               e.chunk,
                               e.embedding
                        FROM documentation_embeddings e
                        ORDER BY e.embedding <=> $1
                        LIMIT 25),
     doc_counts AS (SELECT c.url,
                           c.path,
                           c.blob_sha,
                           COUNT(*) as chunk_count
                    FROM closest_chunks c
                    GROUP BY c.url, c.path, c.blob_sha
                    ORDER BY chunk_count DESC
                    LIMIT 1)
SELECT d.url,
       d.path,
       d.revision,
       d.content,
       d.blob_sha
FROM doc_counts dc
         JOIN documentation_docs d ON dc.url = d.url AND dc.path = d.path AND dc.blob_sha = d.blob_sha
`

func (q *Queries) GetDocumentForUpdate(ctx context.Context, embedding *pgvector.Vector) (DocumentationDoc, error) {
	row := q.db.QueryRow(ctx, getDocumentForUpdate, embedding)
	var i DocumentationDoc
	err := row.Scan(
		&i.Url,
		&i.Path,
		&i.Revision,
		&i.Content,
		&i.BlobSha,
	)
	return i, err
}

const getDocumentationStatus = `-- name: GetDocumentationStatus :many
SELECT 
    ds.url AS source,
    ds.revision,
    ds.refresh_ts,
    (SELECT COUNT(path) FROM documentation_docs WHERE url = ds.url) AS document_count,
    (SELECT COUNT(chunk_index) FROM documentation_embeddings WHERE url = ds.url) AS chunk_count
FROM documentation_status ds
ORDER BY ds.url
`

type GetDocumentationStatusRow struct {
	Source        string
	Revision      string
	RefreshTs     pgtype.Timestamptz
	DocumentCount int64
	ChunkCount    int64
}

func (q *Queries) GetDocumentationStatus(ctx context.Context) ([]GetDocumentationStatusRow, error) {
	rows, err := q.db.Query(ctx, getDocumentationStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentationStatusRow
	for rows.Next() {
		var i GetDocumentationStatusRow
		if err := rows.Scan(
			&i.Source,
			&i.Revision,
			&i.RefreshTs,
			&i.DocumentCount,
			&i.ChunkCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrInsertDocumentationSource = `-- name: GetOrInsertDocumentationSource :one
INSERT INTO documentation_status (url)
VALUES ($1)
ON CONFLICT (url) DO UPDATE SET url = EXCLUDED.url
RETURNING url, revision, refresh_ts
`

func (q *Queries) GetOrInsertDocumentationSource(ctx context.Context, url string) (DocumentationStatus, error) {
	row := q.db.QueryRow(ctx, getOrInsertDocumentationSource, url)
	var i DocumentationStatus
	err := row.Scan(&i.Url, &i.Revision, &i.RefreshTs)
	return i, err
}

const insertDocWithEmbeddings = `-- name: InsertDocWithEmbeddings :exec
WITH should_update AS (SELECT (NOT EXISTS (SELECT 1
                                           FROM documentation_docs
                                           WHERE documentation_docs.url = $4
                                             AND documentation_docs.path = $5
                                             AND documentation_docs.revision = $6)) AS needs_update),
     delete_old_embeddings AS (
         DELETE FROM documentation_embeddings
             WHERE documentation_embeddings.url = $4
                 AND documentation_embeddings.path = $5
                 AND documentation_embeddings.blob_sha != $7
                 AND (SELECT needs_update FROM should_update)),
     doc_insert AS (
         INSERT INTO documentation_docs (url, path, revision, blob_sha, content)
             VALUES ($4, $5, $6, $7, $8)
             ON CONFLICT (url, path) DO UPDATE
                 SET content = EXCLUDED.content, revision = EXCLUDED.revision, blob_sha = EXCLUDED.blob_sha
                 WHERE (SELECT needs_update FROM should_update)
             RETURNING url, path, blob_sha)
INSERT
INTO documentation_embeddings (url, path, blob_sha, chunk_index, chunk, embedding)
SELECT (SELECT url FROM doc_insert),
       (SELECT path FROM doc_insert),
       (SELECT blob_sha FROM doc_insert),
       unnest($1::int[]),
       unnest($2::text[]),
       unnest($3::vector(768)[])
WHERE (SELECT needs_update FROM should_update)
`

type InsertDocWithEmbeddingsParams struct {
	ChunkIndices []int32
	Chunks       []string
	Embeddings   []*pgvector.Vector
	Url          string
	Path         string
	Revision     string
	BlobSha      string
	Content      string
}

func (q *Queries) InsertDocWithEmbeddings(ctx context.Context, arg InsertDocWithEmbeddingsParams) error {
	_, err := q.db.Exec(ctx, insertDocWithEmbeddings,
		arg.ChunkIndices,
		arg.Chunks,
		arg.Embeddings,
		arg.Url,
		arg.Path,
		arg.Revision,
		arg.BlobSha,
		arg.Content,
	)
	return err
}

const updateDocumentRevisionIfSHAMatches = `-- name: UpdateDocumentRevisionIfSHAMatches :one
UPDATE documentation_docs
SET revision = $1
WHERE url = $2
  AND path = $3
  AND blob_sha = $4
RETURNING url, path, revision, content, blob_sha
`

type UpdateDocumentRevisionIfSHAMatchesParams struct {
	NewRevision string
	Url         string
	Path        string
	BlobSha     string
}

func (q *Queries) UpdateDocumentRevisionIfSHAMatches(ctx context.Context, arg UpdateDocumentRevisionIfSHAMatchesParams) (DocumentationDoc, error) {
	row := q.db.QueryRow(ctx, updateDocumentRevisionIfSHAMatches,
		arg.NewRevision,
		arg.Url,
		arg.Path,
		arg.BlobSha,
	)
	var i DocumentationDoc
	err := row.Scan(
		&i.Url,
		&i.Path,
		&i.Revision,
		&i.Content,
		&i.BlobSha,
	)
	return i, err
}

const updateDocumentationSource = `-- name: UpdateDocumentationSource :exec
WITH delete_old_docs AS (
    DELETE FROM documentation_docs
    WHERE url = $2
      AND revision != $1
)
UPDATE documentation_status
SET revision   = $1, refresh_ts = now()
WHERE documentation_status.url = $2
`

type UpdateDocumentationSourceParams struct {
	Revision string
	Url      string
}

func (q *Queries) UpdateDocumentationSource(ctx context.Context, arg UpdateDocumentationSourceParams) error {
	_, err := q.db.Exec(ctx, updateDocumentationSource, arg.Revision, arg.Url)
	return err
}
