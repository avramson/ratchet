// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: documentation.sql

package schema

import (
	"context"

	"github.com/pgvector/pgvector-go"
)

const deleteDoc = `-- name: DeleteDoc :exec
DELETE
FROM documentation_docs
WHERE url = $1
  AND path = $2
`

type DeleteDocParams struct {
	Url  string
	Path string
}

func (q *Queries) DeleteDoc(ctx context.Context, arg DeleteDocParams) error {
	_, err := q.db.Exec(ctx, deleteDoc, arg.Url, arg.Path)
	return err
}

const getClosestDocs = `-- name: GetClosestDocs :many
WITH closest_chunks AS (SELECT DISTINCT ON (e.url, e.path) e.url,
                                                           e.path,
                                                           e.revision,
                                                           e.chunk_index,
                                                           e.chunk,
                                                           e.embedding
                        FROM documentation_embeddings e
                        ORDER BY e.url, e.path, e.embedding <=> $1
                        LIMIT $2)
SELECT c.url,
       c.path,
       c.revision,
       d.content
FROM closest_chunks c
         JOIN documentation_docs d ON c.url = d.url AND c.path = d.path AND c.revision = d.revision
`

type GetClosestDocsParams struct {
	Embedding *pgvector.Vector
	LimitVal  int32
}

type GetClosestDocsRow struct {
	Url      string
	Path     string
	Revision string
	Content  string
}

func (q *Queries) GetClosestDocs(ctx context.Context, arg GetClosestDocsParams) ([]GetClosestDocsRow, error) {
	rows, err := q.db.Query(ctx, getClosestDocs, arg.Embedding, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClosestDocsRow
	for rows.Next() {
		var i GetClosestDocsRow
		if err := rows.Scan(
			&i.Url,
			&i.Path,
			&i.Revision,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocument = `-- name: GetDocument :one
SELECT url, path, revision, content
FROM documentation_docs
WHERE url = $1
  AND path = $2
  AND revision = $3
`

type GetDocumentParams struct {
	Url      string
	Path     string
	Revision string
}

func (q *Queries) GetDocument(ctx context.Context, arg GetDocumentParams) (DocumentationDoc, error) {
	row := q.db.QueryRow(ctx, getDocument, arg.Url, arg.Path, arg.Revision)
	var i DocumentationDoc
	err := row.Scan(
		&i.Url,
		&i.Path,
		&i.Revision,
		&i.Content,
	)
	return i, err
}

const getDocumentForUpdate = `-- name: GetDocumentForUpdate :one
WITH closest_chunks AS (SELECT e.url,
                               e.path,
                               e.revision,
                               e.chunk_index,
                               e.chunk,
                               e.embedding
                        FROM documentation_embeddings e
                        ORDER BY e.embedding <=> $1
                        LIMIT 15),
     doc_counts AS (SELECT c.url,
                           c.path,
                           c.revision,
                           COUNT(*) as chunk_count
                    FROM closest_chunks c
                    GROUP BY c.url, c.path, c.revision
                    ORDER BY chunk_count DESC
                    LIMIT 1)
SELECT d.url,
       d.path,
       d.revision,
       d.content
FROM doc_counts dc
         JOIN documentation_docs d ON dc.url = d.url AND dc.path = d.path AND dc.revision = d.revision
`

func (q *Queries) GetDocumentForUpdate(ctx context.Context, embedding *pgvector.Vector) (DocumentationDoc, error) {
	row := q.db.QueryRow(ctx, getDocumentForUpdate, embedding)
	var i DocumentationDoc
	err := row.Scan(
		&i.Url,
		&i.Path,
		&i.Revision,
		&i.Content,
	)
	return i, err
}

const getOrInsertDocumentationSource = `-- name: GetOrInsertDocumentationSource :one
INSERT INTO documentation_status (url)
VALUES ($1)
ON CONFLICT (url) DO UPDATE SET url = EXCLUDED.url
RETURNING url, revision, refresh_ts
`

func (q *Queries) GetOrInsertDocumentationSource(ctx context.Context, url string) (DocumentationStatus, error) {
	row := q.db.QueryRow(ctx, getOrInsertDocumentationSource, url)
	var i DocumentationStatus
	err := row.Scan(&i.Url, &i.Revision, &i.RefreshTs)
	return i, err
}

const insertDocWithEmbeddings = `-- name: InsertDocWithEmbeddings :exec
WITH should_update AS (SELECT (NOT EXISTS (SELECT 1
                                           FROM documentation_docs
                                           WHERE documentation_docs.url = $4
                                             AND documentation_docs.path = $5
                                             AND documentation_docs.revision = $6)) AS needs_update),
     delete_old_embeddings AS (
         DELETE FROM documentation_embeddings
             WHERE documentation_embeddings.url = $4
                 AND documentation_embeddings.path = $5
                 AND documentation_embeddings.revision != $6
                 AND (SELECT needs_update FROM should_update)),
     doc_insert AS (
         INSERT INTO documentation_docs (url, path, revision, content)
             VALUES ($4, $5, $6, $7)
             ON CONFLICT (url, path) DO UPDATE
                 SET content = EXCLUDED.content, revision = EXCLUDED.revision
                 WHERE (SELECT needs_update FROM should_update)
             RETURNING url, path, revision)
INSERT
INTO documentation_embeddings (url, path, revision, chunk_index, chunk, embedding)
SELECT (SELECT url FROM doc_insert),
       (SELECT path FROM doc_insert),
       (SELECT revision FROM doc_insert),
       unnest($1::int[]),
       unnest($2::text[]),
       unnest($3::vector(768)[])
WHERE (SELECT needs_update FROM should_update)
`

type InsertDocWithEmbeddingsParams struct {
	ChunkIndices []int32
	Chunks       []string
	Embeddings   []*pgvector.Vector
	Url          string
	Path         string
	Revision     string
	Content      string
}

func (q *Queries) InsertDocWithEmbeddings(ctx context.Context, arg InsertDocWithEmbeddingsParams) error {
	_, err := q.db.Exec(ctx, insertDocWithEmbeddings,
		arg.ChunkIndices,
		arg.Chunks,
		arg.Embeddings,
		arg.Url,
		arg.Path,
		arg.Revision,
		arg.Content,
	)
	return err
}

const updateDocumentationSource = `-- name: UpdateDocumentationSource :exec
UPDATE documentation_status
SET revision   = $1,
    refresh_ts = now()
WHERE url = $2
`

type UpdateDocumentationSourceParams struct {
	Revision string
	Url      string
}

func (q *Queries) UpdateDocumentationSource(ctx context.Context, arg UpdateDocumentationSourceParams) error {
	_, err := q.db.Exec(ctx, updateDocumentationSource, arg.Revision, arg.Url)
	return err
}
