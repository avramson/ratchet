// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: incidents.sql

package schema

import (
	"context"
)

const closeIncident = `-- name: CloseIncident :one
UPDATE incidents
SET end_timestamp = now()
WHERE incident_id = $1::integer
RETURNING incident_id
`

func (q *Queries) CloseIncident(ctx context.Context, incidentID int32) (int32, error) {
	row := q.db.QueryRow(ctx, closeIncident, incidentID)
	var incident_id int32
	err := row.Scan(&incident_id)
	return incident_id, err
}

const findActiveIncident = `-- name: FindActiveIncident :one
SELECT incident_id
FROM incidents
WHERE alert = $1
  AND service = $2
  AND end_timestamp IS NULL
LIMIT 1
`

type FindActiveIncidentParams struct {
	Alert   string
	Service string
}

func (q *Queries) FindActiveIncident(ctx context.Context, arg FindActiveIncidentParams) (int32, error) {
	row := q.db.QueryRow(ctx, findActiveIncident, arg.Alert, arg.Service)
	var incident_id int32
	err := row.Scan(&incident_id)
	return incident_id, err
}

const openIncident = `-- name: OpenIncident :one
INSERT INTO incidents (
    channel_id,
    slack_ts,
    alert,
    service,
    priority,
    start_timestamp
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    now()
)
ON CONFLICT (channel_id, slack_ts)
DO UPDATE SET
    alert = EXCLUDED.alert
RETURNING incident_id
`

type OpenIncidentParams struct {
	ChannelID string
	SlackTs   string
	Alert     string
	Service   string
	Priority  string
}

func (q *Queries) OpenIncident(ctx context.Context, arg OpenIncidentParams) (int32, error) {
	row := q.db.QueryRow(ctx, openIncident,
		arg.ChannelID,
		arg.SlackTs,
		arg.Alert,
		arg.Service,
		arg.Priority,
	)
	var incident_id int32
	err := row.Scan(&incident_id)
	return incident_id, err
}
